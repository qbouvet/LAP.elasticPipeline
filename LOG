------------------------------------------------------------------------------------------------------------
TODO	

	what's the difference between join and merge ? what's the branch ?
	
	try stuff with the circuit(a)
			NB :  can't do operations with different latency (cf NOTES)
	
	make instructions simpler
	
	do a version of the circuit with elasticBuffers (complex version)
			pipeline OP unit - test OP unit 
			add elastic control signal sto register file
			change IFD to be combinatorial and double check changes on this one
	
	is DD unit ok ?
	analyse performance
	memory bypass		-> need antitokens to be useful
	discuss eager join to find error in the design
	
	think/read about antitoken channel issuse	
	implement the latch version of elasticBuffer for comparison
	debug the rest of the early evaluation multiplexer




------------------------------------------------------------------------------------------------------------
NOTES  

	circuit(a) : not a ton of thing to do : namely can't do operations with different latency (otherwise, we could get 2 results to the selector in 1 period -> problem), right ?

	registerFile : cant there be read/write issues ? i.e reading stuff that hasn't been written back yet and stuff ?
	
	registerFile : can write once per clock -> as long as we use synchronous buffers, as if "always ready" ?
		
	delayChannel -> what to do with control signals of the delayed outputs ? don't allow them to stall ?
				is valid even necessary, since these buffers should pretty much move at every clock cycle ?
						
	join : is the (not p_valid) term necessary for the read signal ?
	
																			----------------------------

	in this circuit, the only benefit we get is from the early evaluation, otherwise, pipeline is never going to stall ?
		-> in THIS circuit. change the number of buffers on one of the functions, we'll stall but still have the ability 
			to have swapped the operations and keep a correct circuit	
	even with the early evaluation, it's never going to stall ? 
		-> it is. recall that elastic systems are meant to allow functions to be interchangeable. if you have 2 functions of 
			different length (with different number of buffers), then you'll have to stall at some point. 				
	quel interet d'utiliser des elastic buffers pour stocker/delayer l'adresse et l'opcode ? cf control signals : always ready
		-> for when we stall - cf join at the entrance of register file / possible stalling	
	is the dependency detection unit right ? heavily relies ont the fact that 1 instr/cycle comes from the IFD
		-> need to thange that	
	what is the elastic buffer between the write and read steps ?
		-> reminder that the register file needs to be elastic too	
	what happens if the enable signal stops the shifting, but there's an incomming antitoken 
		->  problem 
		


------------------------------------------------------------------------------------------------------------
DONE
	
	
	do a version of the ciruit with elastic components (simple version, no buffers)	
			changed data providing process
			make size-generic eager fork
			tested all components
			debug OPunit
			test join, test fork
			change IFD and add control signals to it
			do a fork5 for the IFD
			add control signals to OP unit
			do a good 3way join (for multiplexers)
			add control signals to register file
	
	*interrupted*  do a version of the circuit with elastic buffers
			add delay channels for adresse and opcode in IFD
			quick test delayChannel
			make delayChannel

			re-implement elasticBuffers with size-genericity
			implement resolultion unit
	
	understand the eager fork
	implement fork 
	test join (lazy)
	testbench the antitoken channel
	rework the antitoken channel architecture in regards to when the register stops shifting (based on data transiting instead of purely clock)
	testbench for the antitoken channel's shift register
	debugged antitoken channel's shift register















						


