------------------------------------------------------------------------------------------------------------
TODO	

	try stuff with the circuit(a) (mostly allows to test if the control signals work correctly when stalling)
					debug the "1 buffer" version	
			do a delay channel version with oc or argI
			
	make instructions simpler + make it so that (others => '0') is addi r0 r0 r0 to avoid 'X' shitty stuff in simulations
	change RF's join to generic version
			
	implement the "merge" and ""branch"
			what's the difference between join and merge ? what's the branch ? 
					-> branch <-> demultiplexer
	
	try stuff with the circuit(a) (mostly allows to test if the control signals work correctly when stalling)
			NB :  what can we actually do ? cf NOTES
			add 3 buffers just after the OP unuit and check if IFD stall alright		-> alright
					fix delayChannel (buffers output array is enumerated in the wrong order somehow) 
			fix the infinite loop at the end in the "single delay buffer" version of the circuit 
	
	
	do a version of the circuit with elasticBuffers (complex version)
			pipeline OP unit - test OP unit 
			add elastic control signal sto register file
			change IFD to be combinatorial and double check changes on this one
	
	is DD unit ok ?
	analyse performance
	memory bypass		-> need antitokens to be useful
	discuss eager join to find error in the design
	
	think/read about antitoken channel issuse	
	implement the latch version of elasticBuffer for comparison
	debug the rest of the early evaluation multiplexer
	
	document stuff




------------------------------------------------------------------------------------------------------------
NOTES  

	circuit(a) : can you have instructions with different latency ?
			-> when 2 results arrive at selector at the same time, need to select the correct one and stall the other
			-> data can be reordered between very fast and very slow instructions, so would need to reorder the write addresses as well
					-> do a similar delay path for the write addresses based on the opcode
					-> and then, when 2 write addresses arrive at the same time at the register file, select&stall using the same component as the results
		-> surely possible, but worth it ? (since the next version has memory bypasses and stuff that will handle the issue more efficitenly)

	registerFile : cant there be read/write issues ? i.e reading stuff that hasn't been written back yet and stuff ?
	
	registerFile : can write once per clock -> as long as we use synchronous buffers, as if "always ready" ?
		
	delayChannel -> what to do with control signals of the delayed outputs ? don't allow them to stall ?
				is valid even necessary, since these buffers should pretty much move at every clock cycle ?
						
	join : is the (not p_valid) term necessary for the read signal ?
	
																			----------------------------

	in this circuit, the only benefit we get is from the early evaluation, otherwise, pipeline is never going to stall ?
		-> in THIS circuit. change the number of buffers on one of the functions, we'll stall but still have the ability 
			to have swapped the operations and keep a correct circuit	
	even with the early evaluation, it's never going to stall ? 
		-> it is. recall that elastic systems are meant to allow functions to be interchangeable. if you have 2 functions of 
			different length (with different number of buffers), then you'll have to stall at some point. 				
	quel interet d'utiliser des elastic buffers pour stocker/delayer l'adresse et l'opcode ? cf control signals : always ready
		-> for when we stall - cf join at the entrance of register file / possible stalling	
	is the dependency detection unit right ? heavily relies ont the fact that 1 instr/cycle comes from the IFD
		-> need to thange that	
	what is the elastic buffer between the write and read steps ?
		-> reminder that the register file needs to be elastic too	
	what happens if the enable signal stops the shifting, but there's an incomming antitoken 
		->  problem 
		


------------------------------------------------------------------------------------------------------------
DONE
	
	try stuff with the circuit(a) (mostly allows to test if the control signals work correctly when stalling)
			NB :  what can we actually do ? cf NOTES
			add 3 buffers just after the OP unuit and check if IFD stall alright		-> alright
					fix delayChannel (buffers output array is enumerated in the wrong order somehow) 
			add 1 buffer to delay the result arrival to the register file for writeback
	
	do a version of the ciruit with elastic components (simple version, no buffers)	
			changed data providing process
			make size-generic eager fork
			tested all components
			debug OPunit
			test join, test fork
			change IFD and add control signals to it
			do a fork5 for the IFD
			add control signals to OP unit
			do a good 3way join (for multiplexers)
			add control signals to register file
	
	*interrupted*  do a version of the circuit with elastic buffers
			add delay channels for adresse and opcode in IFD
			quick test delayChannel
			make delayChannel

			re-implement elasticBuffers with size-genericity
			implement resolultion unit
	
	understand the eager fork
	implement fork 
	test join (lazy)
	testbench the antitoken channel
	rework the antitoken channel architecture in regards to when the register stops shifting (based on data transiting instead of purely clock)
	testbench for the antitoken channel's shift register
	debugged antitoken channel's shift register















						


